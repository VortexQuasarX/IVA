# -*- coding: utf-8 -*-
"""Untitled24.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oo40ly9NKunw54TdvIGD37GqCGR89OO4
"""

# Import necessary libraries
!apt-get install ffmpeg -y
!pip install ffmpeg-python matplotlib Pillow opencv-python moviepy

# Install FFmpeg
!apt-get update
!apt-get install -y ffmpeg

# Install ffmpeg-python
!pip install ffmpeg-python

# Install ffmpeg and ffmpeg-python
!apt-get install ffmpeg
!pip install ffmpeg-python
!pip install opencv-python
!pip install matplotlib

# Remove existing installation of ffmpeg
!apt-get remove ffmpeg -y

# Download and install the latest version of ffmpeg
!add-apt-repository ppa:savoury1/ffmpeg4 -y
!apt-get update
!apt-get install ffmpeg -y

!pip install ffmpeg-python

import ffmpeg
import matplotlib.pyplot as plt
import numpy as np
from PIL import Image
import cv2
from moviepy.editor import ImageSequenceClip
import os
from google.colab import files
import io

import ffmpeg

# Path to your video file
video_file = '/content/Produce.mp4'

# Extract all frames from the video
!ffmpeg -i {video_file} image%2d.png

# Verification step to list the extracted frames
import glob
frames = glob.glob('image*.png')
print(f'Extracted {len(frames)} frames from {video_file}')

# Ensure ffmpeg-python and matplotlib libraries are installed
!pip install ffmpeg-python
!pip install matplotlib

import subprocess
import json
import matplotlib.pyplot as plt

# Function to get frame types using ffprobe
def get_frame_types(video_file):
    try:
        # Use ffprobe to extract frame information
        result = subprocess.run(
            [
                'ffprobe',
                '-v', 'error',
                '-select_streams', 'v:0',
                '-show_entries', 'frame=pict_type',
                '-of', 'json',
                video_file
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )

        frames = json.loads(result.stdout)['frames']

        # Count frame types
        frame_count = {'I': 0, 'P': 0, 'B': 0}
        for frame in frames:
            pict_type = frame['pict_type']
            frame_count[pict_type] += 1

        return frame_count
    except subprocess.CalledProcessError as e:
        print("Error occurred while running ffprobe:", e.stderr)
        return None

# Analyze frame types
video_file = '/content/Produce.mp4'  # Ensure this path is correct
frame_count = get_frame_types(video_file)

if frame_count:
    # Calculate percentages
    total_frames = sum(frame_count.values())
    percentages = {ftype: (count / total_frames) * 100 for ftype, count in frame_count.items()}

    # Print frame counts and percentages
    print(f"Frame counts: {frame_count}")
    print(f"Percentages: {percentages}")

    # Plot frame distribution
    plt.figure(figsize=(8, 6))
    plt.pie(percentages.values(), labels=percentages.keys(), autopct='%1.1f%%')
    plt.title('Frame Type Distribution')
    plt.show()
else:
    print("Failed to analyze frame types.")

import subprocess
import json
import matplotlib.pyplot as plt

# Function to get bitrate information using ffprobe
def get_bitrate_info(video_file):
    try:
        # Use ffprobe to extract frame information
        result = subprocess.run(
            [
                'ffprobe',
                '-v', 'error',
                '-select_streams', 'v:0',
                '-show_entries', 'frame=pkt_size',
                '-of', 'json',
                video_file
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )

        # Print the entire JSON output for debugging
        print("FFprobe Output:\n", result.stdout)

        frames = json.loads(result.stdout).get('frames', [])

        if not frames:
            print("No frames found in the video file.")
            return None

        # Calculate bitrate for each frame
        bitrates = []
        for i, frame in enumerate(frames):
            if i == 0:
                bitrates.append(0)
            else:
                bitrates.append(int(frame['pkt_size']) * 8)  # Convert size from bytes to bits

        return bitrates
    except subprocess.CalledProcessError as e:
        print("Error occurred while running ffprobe:", e.stderr)
        return None

# Analyze bitrate information
video_file = '/content/Produce.mp4'  # Ensure this path is correct
bitrates = get_bitrate_info(video_file)

if bitrates:
    # Plot bitrate information
    plt.figure(figsize=(12, 6))
    plt.plot(bitrates)
    plt.xlabel('Frame Number')
    plt.ylabel('Bitrate (bits)')
    plt.title('Bitrate per Frame')
    plt.show()
else:
    print("Failed to analyze bitrate information.")

# Specify the path to the video file
video_path = '/content/Produce.mp4'

import os

# Create directories for each frame type
os.makedirs('I_frames', exist_ok=True)
os.makedirs('P_frames', exist_ok=True)
os.makedirs('B_frames', exist_ok=True)

# Extract I-frames
!ffmpeg -i {video_path} -vf "select='eq(pict_type\,I)'" -vsync vfr I_frames/I_frame_%03d.png

# Extract P-frames
!ffmpeg -i {video_path} -vf "select='eq(pict_type\,P)'" -vsync vfr P_frames/P_frame_%03d.png

# Extract B-frames
!ffmpeg -i {video_path} -vf "select='eq(pict_type\,B)'" -vsync vfr B_frames/B_frame_%03d.png

import cv2
import numpy as np
from google.colab.patches import cv2_imshow

# Paths to the first extracted frames
i_frame_path = 'I_frames/I_frame_001.png'
p_frame_path = 'P_frames/P_frame_001.png'
b_frame_path = 'B_frames/B_frame_001.png'

# Load the frames
i_frame = cv2.imread(i_frame_path)
p_frame = cv2.imread(p_frame_path)
b_frame = cv2.imread(b_frame_path)

# Check if frames are loaded properly
if i_frame is None:
    print(f"Error loading frame from {i_frame_path}")
if p_frame is None:
    print(f"Error loading frame from {p_frame_path}")
if b_frame is None:
    print(f"Error loading frame from {b_frame_path}")

# Resize frames to the same height (optional, for consistent display)
# This is only needed if the frames are of different sizes
height = min(i_frame.shape[0], p_frame.shape[0], b_frame.shape[0])
i_frame = cv2.resize(i_frame, (int(i_frame.shape[1] * height / i_frame.shape[0]), height))
p_frame = cv2.resize(p_frame, (int(p_frame.shape[1] * height / p_frame.shape[0]), height))
b_frame = cv2.resize(b_frame, (int(b_frame.shape[1] * height / b_frame.shape[0]), height))

# Concatenate frames horizontally
concatenated_frames = np.concatenate((i_frame, p_frame, b_frame), axis=1)

# Display the concatenated frames
cv2_imshow(concatenated_frames)

import cv2
import numpy as np

def calculate_psnr(img1, img2):
    # Ensure the images are in the same shape and type
    img1 = cv2.resize(img1, (img2.shape[1], img2.shape[0]))
    mse = np.mean((img1 - img2) ** 2)
    if mse == 0:  # MSE is zero means no noise is present in the signal.
        return float('inf')
    PIXEL_MAX = 255.0
    psnr = 20 * np.log10(PIXEL_MAX / np.sqrt(mse))
    return psnr

# Paths to the first extracted frames
i_frame_path = 'I_frames/I_frame_001.png'
p_frame_path = 'P_frames/P_frame_001.png'
b_frame_path = 'B_frames/B_frame_001.png'

# Load the frames
i_frame = cv2.imread(i_frame_path)
p_frame = cv2.imread(p_frame_path)
b_frame = cv2.imread(b_frame_path)

# Check if frames are loaded properly
if i_frame is None:
    print(f"Error loading frame from {i_frame_path}")
if p_frame is None:
    print(f"Error loading frame from {p_frame_path}")
if b_frame is None:
    print(f"Error loading frame from {b_frame_path}")

# PSNR between I-frame and P-frame
psnr_ip = calculate_psnr(i_frame, p_frame)
print(f"PSNR between I-frame and P-frame: {psnr_ip} dB")

# PSNR between I-frame and B-frame
psnr_ib = calculate_psnr(i_frame, b_frame)
print(f"PSNR between I-frame and B-frame: {psnr_ib} dB")

import os

def calculate_average_frame_size(directory):
    total_size = 0
    num_files = 0

    for filename in os.listdir(directory):
        filepath = os.path.join(directory, filename)
        if os.path.isfile(filepath):
            total_size += os.path.getsize(filepath)
            num_files += 1

    if num_files == 0:
        return 0
    return total_size / num_files

# Calculate average file sizes in bytes
average_i_frame_size = calculate_average_frame_size('I_frames')
average_p_frame_size = calculate_average_frame_size('P_frames')
average_b_frame_size = calculate_average_frame_size('B_frames')

# Convert to kilobytes (KB)
average_i_frame_size_kb = average_i_frame_size / 1024
average_p_frame_size_kb = average_p_frame_size / 1024
average_b_frame_size_kb = average_b_frame_size / 1024

print(f"Average I-frame size: {average_i_frame_size_kb:.2f} KB")
print(f"Average P-frame size: {average_p_frame_size_kb:.2f} KB")
print(f"Average B-frame size: {average_b_frame_size_kb:.2f} KB")

import os
import subprocess

# Create a directory to save I-frames
i_frame_dir = "I_frames_reconstructed"
os.makedirs(i_frame_dir, exist_ok=True)

# Extract I-frames using ffmpeg
input_video = "path_to_your_video.mp4"
subprocess.run([
    "ffmpeg", "-i", input_video, "-vf", "select='eq(pict_type\\,I)'", "-vsync", "vfr",
    f"{i_frame_dir}/I_frame_%03d.png"
])

print(f"I-frames have been saved to the directory: {i_frame_dir}")

# Define the path for the output reconstructed video
output_video = "reconstructed_video.mp4"

# Reconstruct video using the extracted I-frames
subprocess.run([
    "ffmpeg", "-framerate", "1", "-i", f"{i_frame_dir}/I_frame_%03d.png", "-c:v", "libx264",
    "-pix_fmt", "yuv420p", "-r", "30", output_video
])

print(f"The reconstructed video has been saved as: {output_video}")

from google.colab import drive
drive.mount('/content/drive')